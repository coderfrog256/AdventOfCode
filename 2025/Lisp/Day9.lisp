(ql:quickload '(:str :binding-arrows :hu.dwim.defclass-star :parseq :lparallel :alexandria))
(defpackage :advent (:use :cl :binding-arrows :hu.dwim.defclass-star))
(in-package :advent)
(declaim (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0) (space 0)))

(defun parse-line (line)
  (mapcar #'parse-integer (str:split "," line)))
(defun parse (input)
  (mapcar #'parse-line (str:lines (str:trim input))))
(defun area (l r)
  (* (1+ (abs (- (first l) (first r))))
     (1+ (abs (- (second l) (second r))))))
(defun part-1 (input)
  (let* ((points (parse input))
         (best nil))
    (dolist (l points)
      (dolist (r points)
        (let ((distance (area l r)))
          (if (or (null best) (> distance best))
              (setf best distance)))))
    best))

(frog:report (part-1 (frog:get-advent-of-code-input 2025 9 :input-suffix "test")))
(frog:report (part-1 (frog:get-advent-of-code-input 2025 9)))

(defun fill-in (l r out)
  (loop with start-x = (min (first l) (first r))
        with end-x = (max (first l) (first r))
        with start-y = (min (second l) (second r))
        with end-y = (max (second l) (second r))
        for y from start-y upto end-y
        do (loop for x from start-x upto end-x
                 do (setf (gethash (cons x y) out) t))))

(defun build-y-bounds (points)
  (let ((edges (list))
        (y-bounds (serapeum:dict))
        (min-y nil)
        (max-y nil))
    (loop for i from 0 below (length points)
          for p1 = (nth i points)
          for p2 = (nth (mod (1+ i) (length points)) points)
          do (push (cons p1 p2) edges))
    (loop for (x y) in points
          do (if (or (null min-y) (< y min-y)) (setf min-y y))
             (if (or (null max-y) (> y max-y)) (setf max-y y)))
    (loop for y from min-y upto max-y
          do (let ((left-x nil)
                   (right-x nil))
               (loop for (p1 . p2) in edges
                     for x1 = (first p1)
                     for y1 = (second p1)
                     for x2 = (first p2)
                     for y2 = (second p2)
                     do (cond
                          ((= x1 x2)
                           (when (and (<= (min y1 y2) y) (<= y (max y1 y2)))
                             (if (or (null left-x) (< x1 left-x)) (setf left-x x1))
                             (if (or (null right-x) (> x1 right-x)) (setf right-x x1))))
                          ((= y1 y)
                           (let ((xmin (min x1 x2))
                                 (xmax (max x1 x2)))
                             (if (or (null left-x) (< xmin left-x)) (setf left-x xmin))
                             (if (or (null right-x) (> xmax right-x)) (setf right-x xmax))))))
               (when (and left-x right-x)
                 (setf (gethash y y-bounds) (cons left-x right-x)))))
    y-bounds))

(defun is-valid (l r y-bounds)
  (let* ((min-rx (min (first l) (first r)))
         (max-rx (max (first l) (first r)))
         (min-ry (min (second l) (second r)))
         (max-ry (max (second l) (second r))))
    (loop for y from min-ry upto max-ry
          for bounds = (gethash y y-bounds)
          always (and bounds
                      (<= (car bounds) min-rx)
                      (<= max-rx (cdr bounds))))))

(defun part-2 (input)
  (let* ((points (parse input))
         (y-bounds (build-y-bounds points))
         (best 0))
    (format t "Built y-bounds for ~a y-levels~%" (hash-table-count y-bounds))
    (dolist (l points)
      (dolist (r points)
        (let ((a (area l r)))
          (when (and (> a best) (is-valid l r y-bounds))
            (setf best a)))))
    best))

(frog:report (part-2 (frog:get-advent-of-code-input 2025 9 :input-suffix "test")))
(frog:report (part-2 (frog:get-advent-of-code-input 2025 9)))
